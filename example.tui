42

42, coconut, vec3(1,2,3), true, nil, {x=10}

[
    42,
    "coconut",
    {
        "x":1,
        "y":2,
        "z":3
    },
    true,
    null,
    {
        "x":10
    }
]

array = {
    ThisIsTheFirstObjectWithIndexZero
    "This is the second object with spaces, so it needs quotes"
    "We don't have any commas after each variable, but we can if we want to.
    Also, quotes and brackets allow us to use newlines",
    surprise = "We can also mix array values with keyed values like in lua"
}

//this is a comment, anything after '//' will be skipped by the parser until the next line
#this is also a comment

width = 400,
height = 200,
halfWidth = width * 0.5,
doubleWidth = width * 2.0,

//if statements can be put right in there with your data
if(width > 300) // brackets optional, 'if width > 300' is also valid
{
    height = height * 2.0
}
else // 'else if' and 'elseif' are both valid too
{
    height = height * 0.5
}

addTariff = function(base)
{
    tariff = 145 / 100
    if(random(2) > 0)
    {
        tariff = 245 / 100
    }
    return (base * (1.0 + tariff))
}

costOfTV = addTariff(500)
costOfPlaystation = addTariff(400)
sadness = 10

for (i = 0, i < 5, i = i + 1)
{
    print("sigh")
    sadness = sadness + 1
}

size = vec2(400,200)
color = vec4(0.0,1.0,0.0,1.0)
halfSize = size * 0.5

value = 10
table = {
    subValue = 20
    subTable = {
        subValue = 30 // creates a new local table.subTable.subValue with the value 30
        
        ..subValue = value // this assigns 10 to the parent subValue (previously 20)
        
        enclosingTable = .. // we can store the parent table '..' in a local variable
        enclosingTable.subValue = value // achieves the same as '..subValue = value'.
        enclosingTable = nil // otherwise we create a circular loop and will hang if we try to log or iterate this table!
        
        ...value = 20 // we can go up multiple levels by adding dots, this modifies the variable created at the top level on the first line
        
        testValue = 1
        
        testFunction = function(valueToSet) { // the same rules apply for functions
            ..testValue = value + 1 // 21, remember we can always *read* the higher level variables directly
            ....value = valueToSet // 4 dots this time to modify
        }

        testFunction(100)
    }
    
    outsideFunc = subTable.testFunction // we can grab a reference to that subTable's function and call it directly here
    outsideFunc(200) // ..value is now 200. '....value' still works, because we find variables relative to where the function was defined, not where it is called
    thisFuncDoesntExist() // error examples/scope.tui:27:attempt to call missing function: thisFuncDoesntExist()
}

a = 10

if(a == 10)
{
    a = 5 //this is assigning to the a variable created above
}

b = a // b is now 5

baseWidth = 400
halfWidth = baseWidth * 0.5
doubleWidth = baseWidth * 2.0
baseWidth = nil
